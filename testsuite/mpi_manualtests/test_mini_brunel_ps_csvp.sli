/*
 *  test_mini_brunel_ps_csvp.sli
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/*
   NOTE: This tests is temporarily run as manual test, til we have fixed #562.
*/


 /* BeginDocumentation
Name: testsuite::test_mini_brunel_ps_csvp - Test parallel simulation of small Brunel-style network

Synopsis: nest_indirect test_mini_brunel_ps_csvp.sli -> -

Description:
   Simulates scaled-down Brunel net with precise timing for different numbers of MPI
   processes and compares results.
   _csvp: use children_on_same_vp to force nodes onto vps blockwise

Author:  May 2012, Plesser, based on brunel_ps.sli

See: brunel_ps.sli
*/

%/unittest (9726) require
%/unittest using

%/shpawn <<     /monitor-stdin  true
%    /monitor-stdout true
%>> SetOptions

/brunel_setup {
/brunel << >> def

brunel begin

/total_num_virtual_procs 4 def
/order 16 total_num_virtual_procs mul def     % scales size of network (total 5*order neurons)


/g      250.0 def    % rel strength, inhibitory synapses
/eta    2.0 def    % nu_ext / nu_thresh

/simtime 1000.0 def % simulation time [ms]
/dt        0.1 def % simulation step length [ms]


% Compute the maximum of postsynaptic potential
% for a synaptic input current of unit amplitude
% (1 pA)
/ComputePSPnorm
{
  % calculate the normalization factor for the PSP
  (
  a = tauMem / tauSyn;
  b = 1.0 / tauSyn - 1.0 / tauMem;
  % time of maximum
  t_max = 1.0/b * (-LambertWm1(-exp(-1.0/a)/a)-1.0/a);
  % maximum of PSP for current of unit amplitude
  exp(1.0)/(tauSyn*CMem*b) * ((exp(-t_max/tauMem) - exp(-t_max/tauSyn)) / b - t_max*exp(-t_max/tauSyn))
  ) ExecMath
}
def

%%% PREPARATION SECTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/NE 4 order mul cvi def  % number of excitatory neurons
/NI 1 order mul cvi def  % number of inhibitory neurons
/N  NI NE add def        % total number of neurons

/epsilon 0.1 def            % connectivity
/CE epsilon NE mul cvi def  % number of excitatory synapses on neuron
/CI epsilon NI mul cvi def  % number of inhibitory synapses on neuron
/C  CE CI add def           % total number of internal synapses per n.
/Cext CE def                % number of external synapses on neuron

/tauMem 20.0 def    % neuron membrane time constant [ms]
/CMem  250.0 def    % membrane capacity [pF]
/tauSyn  0.5 def    % synaptic time constant [ms]
/tauRef  2.0 def    % refractory time [ms]
/U0      0.0 def    % resting potential [mV]
/theta  20.0 def    % threshold


% amplitude of PSP given 1pA current
ComputePSPnorm /J_max_unit Set

% synaptic weights, scaled for our alpha functions, such that
% for constant membrane potential, the peak amplitude of the PSP
% equals J

/delay   1.5 def         % synaptic delay, all connections [ms]
/J       0.1 def         % synaptic weight [mV]
/JE J J_max_unit div def % synaptic weight [pA]
/JI g JE mul neg def     % inhibitory

% threshold rate, equivalent rate of events needed to
% have mean input current equal to threshold
/nu_thresh ((theta * CMem) / (JE*CE*exp(1)*tauMem*tauSyn)) ExecMath def
/nu_ext eta nu_thresh mul def     % external rate per synapse
/p_rate nu_ext Cext mul 1000. mul def % external input rate per neuron
                                        % must be given in Hz

end
}
def % brunel_setup

%%% CONSTRUCTION SECTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

{
  brunel_setup
  /brunel using
    % set resolution and total/local number of threads
    0
    <<
      /resolution  dt
      /total_num_virtual_procs total_num_virtual_procs
      /overwrite_files true    
    >> SetStatus

    % one E subnet per virtual proc
    % divide nodes equally among subnets, all nodes in each on one vp
    NE total_num_virtual_procs mod 0 eq assert
    /E_nets [ total_num_virtual_procs ] 
    { pop /subnet << /children_on_same_vp true >> Create } Table 
    def
    E_nets 
    { ChangeSubnet 
        /iaf_psc_alpha_canon 
        NE total_num_virtual_procs div 
      Create pop 
    } forall 
    0 ChangeSubnet

    % same for I
    NI total_num_virtual_procs mod 0 eq assert
    /I_nets [ total_num_virtual_procs ] 
    { pop /subnet << /children_on_same_vp true >> Create } Table 
    def
    I_nets 
    { ChangeSubnet 
        /iaf_psc_alpha_canon 
        NI total_num_virtual_procs div 
      Create pop 
    } forall 
    0 ChangeSubnet
 
    /expoisson /poisson_generator_ps Create def
    expoisson
    <<                % set firing rate
    /rate p_rate
    >> SetStatus

    /inpoisson /poisson_generator_ps Create def
    inpoisson
    <<
    /rate  p_rate
    >> SetStatus

    /exsd /spike_detector Create def
    exsd
    <<
    /withtime true   % record time of spikes
    /withgid true    % record which neuron spiked
    /precise_times true
    /time_in_steps true    
    /to_file true    
    >> SetStatus

    /E_neurons E_nets { GetGlobalNodes } Map Flatten def
    /I_neurons I_nets { GetGlobalNodes } Map Flatten def
    /allNeurons E_neurons I_neurons join def

    allNeurons
    {
      <<
      /tau_m   tauMem
      /C_m     CMem
      /tau_syn tauSyn
      /t_ref   tauRef
      /E_L     U0
      /V_th    theta
      /V_m     U0
      /V_reset U0
      /C_m     1.0     % capacitance is unity in Brunel model
      >> SetStatus
    } forall

    /static_synapse << /delay delay >> SetDefaults
    /static_synapse /syn_ex << /weight JE >> CopyModel
    /static_synapse /syn_in << /weight JI >> CopyModel
    
    E_neurons
    {
      /target Set
      expoisson target /syn_ex Connect
      E_neurons target CE /syn_ex RandomConvergentConnect
      I_neurons target CI /syn_in RandomConvergentConnect
    } bind % bind improves efficiency
    forall

    I_neurons
    {
      /target Set
      inpoisson target /syn_ex Connect
      E_neurons target CE /syn_ex RandomConvergentConnect
      I_neurons target CI /syn_in RandomConvergentConnect
    } bind forall
    
    E_neurons 
    {
      exsd Connect
    } bind forall
    
    simtime Simulate

    % get events, replace vectors with SLI arrays    
    /ev exsd /events get def
    ev keys { /k Set ev dup k get cva k exch put } forall
    ev 
  endusing
} 
exec

0 GetStatus /sna_counts lookup { info } if

% distributed_process_invariant_events_assert_or_die



    
