/*
 *  test_dict_basic_self_reference.sli
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 */


/* BeginDocumentation
   Name: testsuite::test_dict_basic_self_reference - sli script to test self reference of dictionaries

   Synopsis: (test_dict_basic_self_reference.sli) run

   Description:
   test_dict_basic_self_reference checks whether a dictionary with a first level self-references is 
   correctly destructed.

   In SLI dictionaries are reference counted objects. Copying a dictionary means copying the pointer
   and providing another reference to the same object. If the contents of the dictionary is changed,
   the object remains the same and the change is visible from all references to the object. This behavior
   is unlike the behavior of arrays which are also reference counted but are immediately cloned if the 
   contents is changed via one of the references. Therefore the change to an array from one reference
   is never visible from other potential references. The behavior of arrays is sometimes called "lazy copy".

   As a consequence of these definitions, dictionaries may contain references to themselves which we call
   self references. When a dictionary is destroyed special care needs to be taken to handle the self references
   correctly. Revisions of NEST prior to r10990 where not handling this correctly and causing a memory 
   leak. The memory leak can be exposed by the following lines 
       ulimit -v $((1024*1024))  
       SLI ] {<< /d 0 >> dup begin /d exch def end} loop
   which quickly exhausts the provided memory. This demonstration of the memory leak was provided by 
   Alexander Peyser in April 2014. It is possible that early versions of the SLI interpreter contained 
   code to handle recursive dictionary definitions which got lost over the years.
   

   FirstVersion: April 2014
   Author: Diesmann
   SeeAlso: references, selfreferences, testsuite::test_spike_generator
 */

(unittest) run
/unittest using


<< /x 0 >> /d Set
d begin d /x Set end


% push the dictionary onto the stack
d


% The operator references reports 3 references to the dictionary.
% One contained in the variable d, the second in the reference to itself, and 
% a third one on the stack
{references 3 eq} assert_or_die

% Operators references and selfreferences are both defined to leave the argument 
% on the stack. The same is true for several of the commands primarily intended 
% for internal use for reasons of optimization.
% The operator selfreferences reports one self reference. This is correct, the number
% of self references is independent of the number of references the dictionary object
% receives from outside.
{selfreferences 1 eq} assert_or_die

% The dictionary is still on the stack. In the next line we assign a different value
% to variable d and thereby remove one reference to the dictionary.
0 /d Set

% Consequently two remaining references are now reported. One is the dictionary on the
% stack, and the second one is the self reference.
{references 2 eq} assert_or_die

% With the following pop The dictionary is removed from the stack, thereby it is no longer 
% reachable from outside and removed from memory.

pop

% In r10990 SLI terminates with an exception if quit is called without the prior pop.
% The reason probably is that in this revision only first level self references are handled.
% The error is the attempt to access a locked pointer.

% In r10998 SLI terminates without an exception if quit is called even if the pop is left 
% out.

